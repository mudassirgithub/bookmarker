{"ast":null,"code":"let _ = require('lodash');\n\nlet pify = require('pify');\n\nlet request = require('request');\n\nlet promisedRequest = pify(request);\n\nlet htmlparser2 = require('htmlparser2');\n\nlet ogp = require('./lib/ogp');\n\nlet twitter = require('./lib/twitter');\n\nlet oembed = require('./lib/oembed');\n\nlet debug = require('debug')('unfurled');\n\nlet shouldRollup = ['og:image', 'twitter:image', 'twitter:player', 'og:video', 'og:audio'];\n\nasync function main(url, opts) {\n  opts = _.defaults(opts || Object.create(null), {\n    ogp: true,\n    twitter: true,\n    oembed: true,\n    other: true\n  });\n  let metadata = await scrape(url, opts).then(postProcess);\n\n  if (opts.oembed && metadata.oembed) {\n    let oembedData = await fetch({\n      url: metadata.oembed,\n      json: true\n    }, true);\n\n    if (_.get(oembedData, 'body')) {\n      metadata.oembed = _(oembedData.body).pickBy((v, k) => _.includes(oembed, k)).mapKeys((v, k) => _.camelCase(k)).value();\n    } else {\n      metadata.oembed = null;\n    }\n  }\n\n  return metadata;\n}\n\nfunction fetch(url, promisify = false) {\n  if (!_.isPlainObject(url)) url = {\n    url\n  };\n  let r = promisify ? promisedRequest : request;\n\n  let params = _.merge(url, {\n    headers: {\n      'user-agent': 'facebookexternalhit'\n    }\n  });\n\n  return r.get(params);\n}\n\nasync function scrape(url, opts) {\n  let unfurled = Object.create(null);\n  return new Promise((resolve, reject) => {\n    let parser = new htmlparser2.Parser({\n      onopentag,\n      ontext,\n      onclosetag,\n      onerror,\n      onopentagname\n    }, {\n      decodeEntities: true\n    });\n    let req = fetch(url);\n\n    function onopentagname(tag) {\n      debug('setting tagname to', tag);\n      this._tagname = tag;\n    }\n\n    function onerror(err) {\n      debug('error', err);\n      reject(err);\n    }\n\n    function ontext(text) {\n      if (this._tagname === 'title' && opts.other) {\n        let other = unfurled.other || (unfurled.other = {});\n        other.title = (other.title || '') + text;\n      }\n    }\n\n    function onopentag(name, attr) {\n      let prop = attr.property || attr.name || attr.rel;\n      let val = attr.content || attr.value || attr.href;\n\n      if (opts.oembed && attr.type === 'application/json+oembed') {\n        unfurled.oembed = attr.href;\n        return;\n      }\n\n      let target;\n\n      if (opts.ogp && _.includes(ogp, prop)) {\n        target = unfurled.ogp || (unfurled.ogp = {});\n      } else if (opts.twitter && _.includes(twitter, prop)) {\n        target = unfurled.twitter || (unfurled.twitter = {});\n      } else if (opts.other) {\n        target = unfurled.other || (unfurled.other = {});\n      }\n\n      rollup(target, prop, val);\n    }\n\n    function onclosetag(tag) {\n      if (tag === 'head') {\n        req.abort(); // Parse as little as possible.\n      }\n    }\n\n    req.on('response', function ({\n      headers\n    }) {\n      let validContentTypes = ['text/html', 'application/xhtml+xml'];\n      let contentType = (headers['content-type'] || '').split(/;|;\\s/);\n\n      if (contentType[0].includes('video')) {\n        (unfurled.other || (unfurled.other = {}))._type = 'video';\n      }\n\n      if (contentType[0].includes('image')) {\n        (unfurled.other || (unfurled.other = {}))._type = 'image';\n      }\n\n      if (contentType[0].includes('audio')) {\n        (unfurled.other || (unfurled.other = {}))._type = 'audio';\n      }\n\n      if (_.intersection(validContentTypes, contentType).length === 0) {\n        req.abort();\n      }\n    });\n    req.on('data', data => parser.write(data));\n    req.on('drain', () => {\n      req.resume();\n    });\n    req.on('abort', () => {\n      debug('request aborted');\n      parser.reset();\n    });\n    req.on('end', () => {\n      debug('request ended');\n      resolve(unfurled);\n      parser.end();\n    });\n    req.on('error', err => {\n      debug('request failed', err.message);\n      reject(err);\n      parser.end();\n    });\n  });\n}\n\nfunction rollup(target, name, val) {\n  if (!name || !val) return;\n\n  let rollupAs = _.find(shouldRollup, function (k) {\n    return _.startsWith(name, k);\n  });\n\n  if (rollupAs) {\n    let namePart = name.slice(rollupAs.length);\n    let prop = !namePart ? 'url' : _.camelCase(namePart);\n    rollupAs = _.camelCase(rollupAs);\n    target = target[rollupAs] || (target[rollupAs] = [{}]);\n\n    let last = _.last(target);\n\n    last = last[prop] ? target.push({}) && _.last(target) : last;\n    last[prop] = val;\n    return;\n  }\n\n  let prop = _.camelCase(name);\n\n  target[prop] = val;\n}\n\nfunction postProcess(obj) {\n  let keys = ['ogp.ogImage', 'twitter.twitterImage', 'twitter.twitterPlayer', 'ogp.ogVideo'];\n  return _.each(keys, key => {\n    let val = _.get(obj, key);\n\n    if (!val) return;\n    val = _.orderBy(val, 'width', 'asc');\n    return _.set(obj, key, val);\n  }) && obj;\n}\n\nmodule.exports = main;","map":null,"metadata":{},"sourceType":"script"}